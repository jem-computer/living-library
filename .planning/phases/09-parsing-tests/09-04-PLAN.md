---
phase: 09-parsing-tests
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - test/unit/lib/navigation.test.ts
autonomous: true

must_haves:
  truths:
    - "buildNavTree produces correct hierarchy from file structure"
    - "sortGsdItems sorts phase folders numerically"
    - "GSD folders (phases, research, milestones, todos) sorted before custom folders"
    - "getDisplayName adds .md extension to file IDs"
  artifacts:
    - path: "test/unit/lib/navigation.test.ts"
      provides: "Comprehensive tests for navigation tree building"
      min_lines: 100
  key_links:
    - from: "test/unit/lib/navigation.test.ts"
      to: "src/lib/navigation.js"
      via: "direct import (no astro:content dependency)"
      pattern: "import.*from.*navigation\\.js"
---

<objective>
Create comprehensive tests for navigation tree building and GSD-aware sorting.

Purpose: Requirement PARSE-04 - Unit tests for buildNavTree, sortGsdItems
Output: navigation.test.ts with 8+ test cases covering tree building and sorting
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-parsing-tests/09-RESEARCH.md

# Phase 8 patterns
@test/setup.ts
@src/lib/navigation.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create navigation.test.ts</name>
  <files>test/unit/lib/navigation.test.ts</files>
  <action>
Create test file for navigation.js. NOTE: navigation.js does NOT depend on astro:content - it takes entries as a parameter. Tests can import directly without mocking.

```typescript
// test/unit/lib/navigation.test.ts
import { describe, it, expect } from 'vitest';
import { buildNavTree, sortGsdItems, getDisplayName } from '../../../src/lib/navigation.js';

// Helper to create mock collection entries
function createEntry(id: string) {
  return { id, body: '', data: {}, collection: 'planning' };
}

describe('navigation.js', () => {
  describe('buildNavTree', () => {
    it('should create GSD section at top of navigation', () => {
      const entries = [createEntry('PROJECT')];
      const tree = buildNavTree(entries);

      expect(tree[0].name).toBe('GSD');
      expect(tree[0].children).toHaveLength(4);
      expect(tree[0].children.map(c => c.name)).toEqual([
        'Roadmap', 'Timeline', 'Dependencies', 'Todos'
      ]);
    });

    it('should place root files after GSD section', () => {
      const entries = [
        createEntry('PROJECT'),
        createEntry('ROADMAP'),
        createEntry('REQUIREMENTS')
      ];
      const tree = buildNavTree(entries);

      // GSD section first, then root files
      expect(tree[0].name).toBe('GSD');
      expect(tree.slice(1).map(n => n.name)).toContain('PROJECT.md');
      expect(tree.slice(1).map(n => n.name)).toContain('ROADMAP.md');
    });

    it('should filter out STATE.md from navigation', () => {
      const entries = [
        createEntry('PROJECT'),
        createEntry('STATE')
      ];
      const tree = buildNavTree(entries);

      const allNames = tree.flatMap(n =>
        n.children ? n.children.map(c => c.name) : [n.name]
      );
      expect(allNames).not.toContain('STATE.md');
    });

    it('should build nested folder structure', () => {
      const entries = [
        createEntry('phases/01-foundation/01-01-PLAN'),
        createEntry('phases/01-foundation/01-01-SUMMARY'),
        createEntry('phases/02-features/02-01-PLAN')
      ];
      const tree = buildNavTree(entries);

      // Find phases folder
      const phasesFolder = tree.find(n => n.name === 'phases');
      expect(phasesFolder).toBeDefined();
      expect(phasesFolder.children).toBeDefined();

      // Should have two phase subfolders
      const phaseSubfolders = phasesFolder.children.filter(c => c.children);
      expect(phaseSubfolders).toHaveLength(2);
    });

    it('should sort phase folders numerically within phases', () => {
      const entries = [
        createEntry('phases/10-final/10-01-PLAN'),
        createEntry('phases/02-second/02-01-PLAN'),
        createEntry('phases/01-first/01-01-PLAN')
      ];
      const tree = buildNavTree(entries);

      const phasesFolder = tree.find(n => n.name === 'phases');
      const phaseNames = phasesFolder.children.map(c => c.name);

      // Should be sorted: 01, 02, 10 (not alphabetically: 01, 10, 02)
      expect(phaseNames).toEqual(['01-first', '02-second', '10-final']);
    });

    it('should handle empty entries array', () => {
      const tree = buildNavTree([]);

      // Should still have GSD section
      expect(tree[0].name).toBe('GSD');
      expect(tree).toHaveLength(1);  // Only GSD section
    });
  });

  describe('sortGsdItems', () => {
    it('should sort phase folders numerically', () => {
      const items = [
        { name: '10-final', path: 'phases/10-final', children: [] },
        { name: '2-second', path: 'phases/2-second', children: [] },
        { name: '1-first', path: 'phases/1-first', children: [] }
      ];

      const sorted = sortGsdItems(items);

      expect(sorted.map(i => i.name)).toEqual(['1-first', '2-second', '10-final']);
    });

    it('should place GSD folders before non-GSD folders', () => {
      const items = [
        { name: 'custom', path: 'custom', children: [] },
        { name: 'phases', path: 'phases', children: [] },
        { name: 'research', path: 'research', children: [] },
        { name: 'another', path: 'another', children: [] }
      ];

      const sorted = sortGsdItems(items);

      // GSD folders (phases, research) should come first
      expect(sorted[0].name).toBe('phases');
      expect(sorted[1].name).toBe('research');
      // Non-GSD folders should follow (alphabetically)
      expect(sorted[2].name).toBe('another');
      expect(sorted[3].name).toBe('custom');
    });

    it('should recognize all GSD folder types', () => {
      const items = [
        { name: 'random', path: 'random', children: [] },
        { name: 'todos', path: 'todos', children: [] },
        { name: 'milestones', path: 'milestones', children: [] },
        { name: 'research', path: 'research', children: [] },
        { name: 'phases', path: 'phases', children: [] }
      ];

      const sorted = sortGsdItems(items);

      // All 4 GSD folders should come before 'random'
      const gsdFolders = ['phases', 'research', 'milestones', 'todos'];
      const firstFour = sorted.slice(0, 4).map(i => i.name);
      expect(firstFour.every(n => gsdFolders.includes(n))).toBe(true);
      expect(sorted[4].name).toBe('random');
    });

    it('should sort files alphabetically within a folder', () => {
      const items = [
        { name: 'REQUIREMENTS.md', path: '/REQUIREMENTS' },
        { name: 'PROJECT.md', path: '/PROJECT' },
        { name: 'ROADMAP.md', path: '/ROADMAP' }
      ];

      const sorted = sortGsdItems(items);

      expect(sorted.map(i => i.name)).toEqual([
        'PROJECT.md', 'REQUIREMENTS.md', 'ROADMAP.md'
      ]);
    });

    it('should handle paths with leading slashes', () => {
      const items = [
        { name: 'custom', path: '/custom', children: [] },
        { name: 'phases', path: '/phases', children: [] }
      ];

      const sorted = sortGsdItems(items);

      // Should still recognize phases as GSD folder
      expect(sorted[0].name).toBe('phases');
    });
  });

  describe('getDisplayName', () => {
    it('should add .md extension to file IDs', () => {
      expect(getDisplayName('PROJECT')).toBe('PROJECT.md');
      expect(getDisplayName('ROADMAP')).toBe('ROADMAP.md');
    });

    it('should extract filename from nested path', () => {
      expect(getDisplayName('phases/01-foundation/01-01-PLAN')).toBe('01-01-PLAN.md');
    });

    it('should not double .md extension', () => {
      expect(getDisplayName('phases/01-foundation/01-01-PLAN.md')).toBe('01-01-PLAN.md');
    });

    it('should handle single segment IDs', () => {
      expect(getDisplayName('REQUIREMENTS')).toBe('REQUIREMENTS.md');
    });
  });

  describe('integration', () => {
    it('should produce navigable tree from realistic entries', () => {
      const entries = [
        createEntry('PROJECT'),
        createEntry('ROADMAP'),
        createEntry('REQUIREMENTS'),
        createEntry('phases/01-foundation/01-01-PLAN'),
        createEntry('phases/01-foundation/01-01-SUMMARY'),
        createEntry('phases/02-features/02-01-PLAN'),
        createEntry('research/tech-evaluation'),
        createEntry('milestones/v1.0-roadmap')
      ];

      const tree = buildNavTree(entries);

      // Should have: GSD section, root files, folders
      expect(tree.length).toBeGreaterThan(3);

      // GSD section should be first
      expect(tree[0].name).toBe('GSD');

      // Root files should follow
      const rootFileNames = tree.filter(n => !n.children || n.children.length === 0 || n.name === 'GSD')
        .filter(n => n.name !== 'GSD')
        .map(n => n.name);
      expect(rootFileNames).toContain('PROJECT.md');

      // Folders should be at the end
      const folders = tree.filter(n => n.children && n.name !== 'GSD');
      expect(folders.map(f => f.name)).toContain('phases');
    });
  });
});
```
  </action>
  <verify>`npm test -- navigation.test.ts` - all tests pass</verify>
  <done>navigation.test.ts has 10+ passing tests covering tree building, sorting, display names, and edge cases</done>
</task>

</tasks>

<verification>
1. `npm test -- navigation.test.ts` passes all tests
2. `npm run coverage` shows >80% coverage for navigation.js
3. Tests cover tree building, GSD-aware sorting, display names, and edge cases
</verification>

<success_criteria>
- buildNavTree produces correct hierarchy from file structure
- GSD section appears at top with Roadmap, Timeline, Dependencies, Todos
- sortGsdItems sorts phase folders numerically (01, 02, 10 not 01, 10, 02)
- GSD folders (phases, research, milestones, todos) sorted before custom folders
- getDisplayName adds .md extension to file IDs
- STATE.md filtered from navigation
</success_criteria>

<output>
After completion, create `.planning/phases/09-parsing-tests/09-04-SUMMARY.md`
</output>
