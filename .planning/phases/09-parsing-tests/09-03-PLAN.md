---
phase: 09-parsing-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - test/unit/lib/dependencies.test.ts
autonomous: true

must_haves:
  truths:
    - "buildDependencyGraph produces nodes and edges from phase data"
    - "parsePhases extracts phase status (complete/active/pending)"
    - "Dependencies are parsed from **Depends on**: Phase N"
    - "Archived milestones are included in the graph"
  artifacts:
    - path: "test/unit/lib/dependencies.test.ts"
      provides: "Comprehensive tests for dependency graph"
      min_lines: 100
  key_links:
    - from: "test/unit/lib/dependencies.test.ts"
      to: "src/lib/dependencies.js"
      via: "dynamic import after vi.mock"
      pattern: "await import\\(.*dependencies\\.js"
---

<objective>
Create comprehensive tests for dependency graph building from ROADMAP.md.

Purpose: Requirement PARSE-03 - Unit tests for buildDependencyGraph, parseRoadmap
Output: dependencies.test.ts with 8+ test cases covering graph construction
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-parsing-tests/09-RESEARCH.md

# Phase 8 patterns
@test/setup.ts
@src/lib/dependencies.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dependencies.test.ts</name>
  <files>test/unit/lib/dependencies.test.ts</files>
  <action>
Create test file for dependencies.js. Note: dependencies.js has its own parsePhases function (different from milestones.js) that produces graph nodes/edges.

```typescript
// test/unit/lib/dependencies.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { getEntry, getCollection } from 'astro:content';
import { mockContentEntry } from '../../setup.js';

describe('dependencies.js', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('buildDependencyGraph', () => {
    it('should return empty graph when no roadmap exists', async () => {
      vi.mocked(getEntry).mockResolvedValue(null);
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes).toEqual([]);
      expect(graph.edges).toEqual([]);
      expect(graph.milestones).toEqual([]);
    });

    it('should create nodes for each phase', async () => {
      const mockBody = `# Milestone v1.2: Testing

### Phase 8: Test Infrastructure
**Goal:** Vitest setup

### Phase 9: Parsing Tests
**Goal:** Unit tests`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes).toHaveLength(2);
      expect(graph.nodes[0].id).toBe('phase-8');
      expect(graph.nodes[0].label).toBe('Phase 8: Test Infrastructure');
      expect(graph.nodes[1].id).toBe('phase-9');
    });

    it('should create edges from dependency declarations', async () => {
      const mockBody = `# Milestone v1.2: Testing

### Phase 8: Test Infrastructure
**Goal:** Vitest setup

### Phase 9: Parsing Tests
**Goal:** Unit tests
**Depends on**: Phase 8`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.edges).toHaveLength(1);
      expect(graph.edges[0]).toEqual({
        source: 'phase-8',
        target: 'phase-9'
      });
    });

    it('should include archived milestones in graph', async () => {
      const currentBody = `# Milestone v1.2: Testing

### Phase 8: Test Infrastructure`;

      const archivedBody = `# Milestone v1.0: Foundation

### Phase 1: Setup ✓
**Completed:** 2026-01-20

### Phase 2: Core ✓
**Completed:** 2026-01-22`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', currentBody));
      vi.mocked(getCollection).mockResolvedValue([
        mockContentEntry('milestones/v1.0-roadmap', archivedBody)
      ]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes).toHaveLength(3);  // 1 current + 2 archived
      expect(graph.milestones).toContain('v1.2');
      expect(graph.milestones).toContain('v1.0');
    });

    it('should sort milestones by version (newest first)', async () => {
      const currentBody = `# Milestone v1.2: Testing

### Phase 8: Test`;

      const archived10 = mockContentEntry('milestones/v1.0-roadmap',
        `# Milestone v1.0: MVP\n\n### Phase 1: First ✓`);
      const archived11 = mockContentEntry('milestones/v1.1-roadmap',
        `# Milestone v1.1: Polish\n\n### Phase 5: Second ✓`);

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', currentBody));
      vi.mocked(getCollection).mockResolvedValue([archived10, archived11]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.milestones).toEqual(['v1.2', 'v1.1', 'v1.0']);
    });
  });

  describe('parsePhases (internal)', () => {
    it('should set status to complete for phases with checkmark', async () => {
      const mockBody = `# Milestone v1.0: Test

### Phase 1: Done ✓
**Completed:** 2026-01-20`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes[0].status).toBe('complete');
    });

    it('should set status to active for first incomplete phase', async () => {
      const mockBody = `# Milestone v1.0: Test

### Phase 1: Done ✓
**Completed:** 2026-01-20

### Phase 2: In Progress
**Goal:** Current work

### Phase 3: Future
**Goal:** Later work`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes[0].status).toBe('complete');
      expect(graph.nodes[1].status).toBe('active');
      expect(graph.nodes[2].status).toBe('pending');
    });

    it('should generate correct URLs for phases', async () => {
      const mockBody = `# Milestone v1.0: Test

### Phase 5: Distribution & Naming
**Goal:** npm setup`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      // Should slugify and pad number
      expect(graph.nodes[0].url).toBe('/phases/05-distribution-naming/');
    });

    it('should handle roadmap with no phases gracefully', async () => {
      const mockBody = `# Milestone v1.0: Empty

**Goal:** No phases yet`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes).toEqual([]);
      expect(graph.edges).toEqual([]);
    });
  });

  describe('slugify (internal)', () => {
    it('should convert phase names to URL-friendly slugs', async () => {
      const mockBody = `# Milestone v1.0: Test

### Phase 1: CLI Foundation & Dev Server
**Goal:** Setup`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      // "CLI Foundation & Dev Server" -> "cli-foundation-dev-server"
      expect(graph.nodes[0].url).toContain('cli-foundation-dev-server');
    });
  });

  describe('padNumber (internal)', () => {
    it('should pad single digit phase numbers', async () => {
      const mockBody = `# Milestone v1.0: Test

### Phase 5: Fifth
**Goal:** Test`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes[0].url).toMatch(/\/05-/);
    });

    it('should not pad double digit phase numbers', async () => {
      const mockBody = `# Milestone v1.0: Test

### Phase 11: Eleventh
**Goal:** Test`;

      vi.mocked(getEntry).mockResolvedValue(mockContentEntry('roadmap', mockBody));
      vi.mocked(getCollection).mockResolvedValue([]);

      const { buildDependencyGraph } = await import('../../../src/lib/dependencies.js');
      const graph = await buildDependencyGraph();

      expect(graph.nodes[0].url).toMatch(/\/11-/);
    });
  });
});
```
  </action>
  <verify>`npm test -- dependencies.test.ts` - all tests pass</verify>
  <done>dependencies.test.ts has 10+ passing tests covering graph nodes, edges, status, URLs, and edge cases</done>
</task>

</tasks>

<verification>
1. `npm test -- dependencies.test.ts` passes all tests
2. `npm run coverage` shows >80% coverage for dependencies.js
3. Tests cover nodes, edges, status determination, URL generation, and archived milestones
</verification>

<success_criteria>
- buildDependencyGraph produces nodes with correct id, label, status, milestone, url
- Dependency edges are created from **Depends on**: Phase N declarations
- Phase status correctly determined: complete (checkmark/date), active (first incomplete), pending
- Archived milestones included and sorted by version
- Edge cases (empty roadmap, no phases) handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/09-parsing-tests/09-03-SUMMARY.md`
</output>
