---
phase: 01-cli-foundation-dev-server
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/ui/colors.js
  - src/ui/spinner.js
  - src/dev-server.js
  - src/scaffold/prompt.js
  - astro.config.mjs
autonomous: true

must_haves:
  truths:
    - "Spinner shows during server startup with CI-aware degradation"
    - "Colors respect NO_COLOR environment variable"
    - "Dev server starts Astro programmatically on available port"
    - "Scaffold prompt offers to create .planning when missing"
  artifacts:
    - path: "src/ui/colors.js"
      provides: "Picocolors theme helpers"
      exports:
        - colors
        - formatUrl
        - formatPath
    - path: "src/ui/spinner.js"
      provides: "Ora wrapper with CI detection"
      exports:
        - createSpinner
    - path: "src/dev-server.js"
      provides: "Astro dev server wrapper"
      exports:
        - startDevServer
    - path: "src/scaffold/prompt.js"
      provides: "Interactive scaffold prompt"
      exports:
        - promptScaffold
    - path: "astro.config.mjs"
      provides: "Minimal Astro configuration"
      contains: "defineConfig"
  key_links:
    - from: "src/dev-server.js"
      to: "astro"
      via: "programmatic dev() import"
      pattern: "import.*from.*astro"
    - from: "src/ui/spinner.js"
      to: "ora"
      via: "ora import"
      pattern: "import.*ora"
    - from: "src/scaffold/prompt.js"
      to: "@inquirer/prompts"
      via: "confirm/input prompts"
      pattern: "import.*@inquirer/prompts"
---

<objective>
Create the terminal UI modules (colors, spinner) and core functionality (dev server wrapper, scaffold prompt) that will be wired together in Plan 03.

Purpose: Build the reusable components that make the CLI feel polished and handle the two main flows: starting a dev server when .planning exists, or scaffolding when it doesn't.
Output: Four independent modules ready to be imported and used by the CLI entry point.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-cli-foundation-dev-server/01-RESEARCH.md
@.planning/phases/01-cli-foundation-dev-server/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create terminal UI modules</name>
  <files>src/ui/colors.js, src/ui/spinner.js</files>
  <action>
Create src/ui/colors.js:
```javascript
import pc from 'picocolors';

/**
 * Themed color helpers for consistent CLI output
 * All respect NO_COLOR automatically via picocolors
 */
export const colors = {
  // States
  success: pc.green,
  error: pc.red,
  warn: pc.yellow,
  info: pc.cyan,

  // Emphasis
  bold: pc.bold,
  dim: pc.dim,

  // Semantic
  url: (str) => pc.cyan(pc.underline(str)),
  path: (str) => pc.dim(str),
  version: (str) => pc.dim(`v${str}`),
  command: (str) => pc.bold(pc.cyan(str))
};

/**
 * Format URL for terminal display
 * @param {string} url
 */
export function formatUrl(url) {
  return colors.url(url);
}

/**
 * Format file path for terminal display
 * @param {string} filePath
 */
export function formatPath(filePath) {
  return colors.path(filePath);
}

/**
 * Format startup banner
 * @param {string} version
 * @param {number} port
 * @param {string} [planningPath]
 */
export function formatStartupBanner(version, port, planningPath) {
  const lines = [
    `${colors.bold('living-library')} ${colors.version(version)}`,
    '',
    `  ${colors.dim('Local:')}   ${formatUrl(`http://localhost:${port}`)}`,
  ];

  if (planningPath && planningPath !== '.planning') {
    lines.push(`  ${colors.dim('Docs:')}    ${formatPath(planningPath)}`);
  }

  return lines.join('\n');
}
```

Create src/ui/spinner.js:
```javascript
import ora from 'ora';
import { colors } from './colors.js';

/**
 * Create a spinner with CI-aware degradation
 * @param {string} text - Initial spinner text
 * @returns {import('ora').Ora}
 */
export function createSpinner(text) {
  return ora({
    text,
    color: 'cyan',
    // ora automatically detects CI and disables animation
  });
}

/**
 * Start spinner and return control functions
 * @param {string} text
 */
export function startSpinner(text) {
  const spinner = createSpinner(text);
  spinner.start();

  return {
    /** Update spinner text */
    update: (newText) => spinner.text = newText,

    /** Stop with success state */
    succeed: (text) => spinner.succeed(colors.success(text || 'Done!')),

    /** Stop with failure state */
    fail: (text) => spinner.fail(colors.error(text || 'Failed')),

    /** Stop spinner without state change (for prompts) */
    stop: () => spinner.stop(),

    /** Clear spinner line */
    clear: () => spinner.clear(),

    /** Get underlying ora instance */
    spinner
  };
}
```
  </action>
  <verify>
Run: `node -e "import('./src/ui/colors.js').then(m => console.log(m.formatStartupBanner('0.1.0', 4321)))"`
  - Shows formatted banner with version and URL
Run: `NO_COLOR=1 node -e "import('./src/ui/colors.js').then(m => console.log(m.formatStartupBanner('0.1.0', 4321)))"`
  - Shows plain text without ANSI codes
Run: `node -e "import('./src/ui/spinner.js').then(m => { const s = m.startSpinner('Test...'); setTimeout(() => s.succeed('OK'), 500); })"`
  - Shows spinner then success state
  </verify>
  <done>
- src/ui/colors.js exports colors object, formatUrl, formatPath, formatStartupBanner
- src/ui/spinner.js exports createSpinner, startSpinner with succeed/fail/stop methods
- Both respect NO_COLOR via picocolors/ora built-in detection
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dev server wrapper and scaffold prompt</name>
  <files>src/dev-server.js, src/scaffold/prompt.js, astro.config.mjs</files>
  <action>
Create astro.config.mjs (minimal config):
```javascript
import { defineConfig } from 'astro/config';

// This config is used by the dev server
// living-library passes root and server options programmatically
export default defineConfig({
  // Intentionally minimal - let programmatic API control settings
});
```

Create src/dev-server.js:
```javascript
import { dev } from 'astro';
import getPort from 'get-port';
import path from 'node:path';
import { colors, formatStartupBanner } from './ui/colors.js';

const DEFAULT_PORT = 4321;

/**
 * @typedef {Object} DevServerOptions
 * @property {string} root - Project root (parent of .planning)
 * @property {boolean} [verbose] - Show Astro's detailed output
 */

/**
 * @typedef {Object} DevServerResult
 * @property {import('astro').DevServer} server - Astro dev server instance
 * @property {number} port - Port server is running on
 * @property {string} url - Full URL to access server
 */

/**
 * Start Astro dev server programmatically
 * @param {DevServerOptions} options
 * @returns {Promise<DevServerResult>}
 */
export async function startDevServer({ root, verbose = false }) {
  // Get available port, preferring default
  const port = await getPort({ port: DEFAULT_PORT });

  if (port !== DEFAULT_PORT) {
    console.log(colors.warn(`Port ${DEFAULT_PORT} in use, using ${port}`));
  }

  // Start Astro dev server with inline config
  // Note: inline config has highest priority per Astro docs
  const server = await dev({
    root: path.resolve(root),
    server: { port },
    logLevel: verbose ? 'debug' : 'warn', // Suppress Astro logs unless verbose
  });

  const url = `http://localhost:${port}`;

  return { server, port, url };
}

/**
 * Register cleanup handlers for graceful shutdown
 * @param {import('astro').DevServer} server
 */
export function registerShutdownHandlers(server) {
  const shutdown = async () => {
    try {
      await server.stop();
    } catch (e) {
      // Ignore errors during shutdown
    }
    process.exit(0);
  };

  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);
}

/**
 * Log file changes from watcher
 * @param {import('astro').DevServer} server
 * @param {string} planningPath - Path to .planning for filtering
 */
export function logFileChanges(server, planningPath) {
  server.watcher.on('change', (changedPath) => {
    // Only log changes within .planning folder
    if (changedPath.includes('.planning')) {
      const filename = path.basename(changedPath);
      console.log(colors.dim(`  Reloading: ${filename} changed`));
    }
  });
}
```

Create src/scaffold/prompt.js:
```javascript
import { confirm, input } from '@inquirer/prompts';
import fs from 'node:fs/promises';
import path from 'node:path';
import { colors } from '../ui/colors.js';

/**
 * Prompt user to scaffold .planning structure
 * @returns {Promise<boolean>} - true if scaffolded, false if cancelled
 */
export async function promptScaffold() {
  console.log(colors.warn('No .planning directory found in current directory or parents.\n'));

  const shouldScaffold = await confirm({
    message: 'Create a sample .planning structure?',
    default: true
  });

  if (!shouldScaffold) {
    console.log(colors.dim('\nRun this command in a directory with a .planning folder.'));
    return false;
  }

  const projectName = await input({
    message: 'Project name:',
    default: path.basename(process.cwd())
  });

  await createScaffold(projectName);

  console.log(colors.success(`\nCreated .planning structure for "${projectName}"`));
  console.log(colors.dim('Run living-library again to start the dev server.\n'));

  return true;
}

/**
 * Create .planning folder structure with sample files
 * @param {string} projectName
 */
async function createScaffold(projectName) {
  const planningDir = path.join(process.cwd(), '.planning');

  await fs.mkdir(planningDir, { recursive: true });
  await fs.mkdir(path.join(planningDir, 'phases'), { recursive: true });

  // Create PROJECT.md
  const projectContent = `# ${projectName}

## What This Is

[Describe your project here]

## Core Value

[What problem does this solve?]

## Requirements

### Active

- [ ] First requirement

### Out of Scope

- Not doing X

## Context

**Target users:** [Who uses this?]

---
*Last updated: ${new Date().toISOString().split('T')[0]}*
`;

  await fs.writeFile(
    path.join(planningDir, 'PROJECT.md'),
    projectContent
  );

  // Create ROADMAP.md
  const roadmapContent = `# Roadmap: ${projectName}

## Phases

- [ ] **Phase 1: Getting Started** - Initial setup

## Phase Details

### Phase 1: Getting Started
**Goal**: [Define what success looks like]
**Depends on**: Nothing (first phase)
**Success Criteria**:
  1. [First measurable outcome]

Plans:
- [ ] TBD

---
*Roadmap created: ${new Date().toISOString().split('T')[0]}*
`;

  await fs.writeFile(
    path.join(planningDir, 'ROADMAP.md'),
    roadmapContent
  );

  // Create STATE.md
  const stateContent = `# Project State

## Current Position

Phase: 1
Status: Ready to plan
Last activity: ${new Date().toISOString().split('T')[0]} - Project initialized

## Accumulated Context

### Decisions

(None yet)

### Pending Todos

(None yet)

---
*State initialized: ${new Date().toISOString().split('T')[0]}*
`;

  await fs.writeFile(
    path.join(planningDir, 'STATE.md'),
    stateContent
  );
}
```
  </action>
  <verify>
Run: `node -e "import('./src/dev-server.js').then(m => console.log('dev-server imports ok'))"`
  - No import errors
Run: `node -e "import('./src/scaffold/prompt.js').then(m => console.log('scaffold imports ok'))"`
  - No import errors
Run: `cat astro.config.mjs`
  - Shows defineConfig
  </verify>
  <done>
- astro.config.mjs exists with minimal defineConfig
- src/dev-server.js exports startDevServer, registerShutdownHandlers, logFileChanges
- src/scaffold/prompt.js exports promptScaffold that creates .planning structure
- All modules import without errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. All 5 files exist in correct locations
2. `node -e "import('./src/ui/colors.js')"` - no errors
3. `node -e "import('./src/ui/spinner.js')"` - no errors
4. `node -e "import('./src/dev-server.js')"` - no errors
5. `node -e "import('./src/scaffold/prompt.js')"` - no errors
6. NO_COLOR=1 test shows colors are stripped
</verification>

<success_criteria>
- Terminal UI modules provide consistent, themed output with NO_COLOR support
- Dev server wrapper can start Astro programmatically with port fallback
- Scaffold prompt creates valid .planning structure with PROJECT.md, ROADMAP.md, STATE.md
- All modules are independent and can be imported without side effects
- Graceful shutdown handlers are available for signal handling
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-foundation-dev-server/01-02-SUMMARY.md`
</output>
